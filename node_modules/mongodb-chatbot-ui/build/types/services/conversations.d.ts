import { type References } from "mongodb-rag-core";
import { ConversationState } from "../useConversation";
export type Role = "user" | "assistant";
export type MessageData = {
    id: string;
    role: Role;
    content: string;
    createdAt: string;
    rating?: boolean;
    references?: References;
    suggestedPrompts?: string[];
};
export declare function formatReferences(references: References): string;
export declare const CUSTOM_REQUEST_ORIGIN_HEADER = "X-Request-Origin";
export declare function getCustomRequestOrigin(): string | undefined;
export declare class TimeoutError<Data extends object = object> extends Error {
    data?: Data;
    constructor(message: string);
}
/**
  Options to include with every fetch request made by the ConversationService.
  This can be used to set headers, etc.
 */
export type ConversationFetchOptions = Omit<RequestInit, "body" | "method" | "headers" | "signal"> & {
    headers?: Headers;
};
export type ConversationServiceConfig = {
    serverUrl: string;
    fetchOptions?: ConversationFetchOptions;
};
export declare class ConversationService {
    private serverUrl;
    private fetchOptions;
    constructor(config: ConversationServiceConfig);
    private mergeHeaders;
    private getUrl;
    createConversation(): Promise<Required<ConversationState>>;
    getConversation(conversationId: string): Promise<Required<ConversationState>>;
    addMessage({ conversationId, message, }: {
        conversationId: string;
        message: string;
    }): Promise<MessageData>;
    addMessageStreaming({ conversationId, message, maxRetries, onResponseDelta, onReferences, onResponseFinished, signal, }: {
        conversationId: string;
        message: string;
        maxRetries?: number;
        onResponseDelta: (delta: string) => void;
        onReferences: (references: References) => void;
        onResponseFinished: (messageId: string) => void;
        signal?: AbortSignal;
    }): Promise<void>;
    rateMessage({ conversationId, messageId, rating, }: {
        conversationId: string;
        messageId: string;
        rating: boolean;
    }): Promise<boolean>;
    commentMessage({ conversationId, messageId, comment, }: {
        conversationId: string;
        messageId: string;
        comment: string;
    }): Promise<void>;
}

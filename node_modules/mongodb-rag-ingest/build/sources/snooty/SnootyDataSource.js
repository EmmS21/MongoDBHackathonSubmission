"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlePage = exports.makeSnootyDataSource = void 0;
const readline_1 = require("readline");
const mongodb_rag_core_1 = require("mongodb-rag-core");
const node_fetch_1 = __importDefault(require("node-fetch"));
const snootyAstToMd_1 = require("./snootyAstToMd");
const snootyAstToOpenApiSpec_1 = require("./snootyAstToOpenApiSpec");
const makeSnootyDataSource = ({ name: sourceName, project, snootyDataApiBaseUrl, }) => {
    const { baseUrl, currentBranch, name: snootyProjectName, tags, productName, version, } = project;
    return {
        // Additional members for testing purposes
        _baseUrl: baseUrl,
        _currentBranch: currentBranch,
        _snootyProjectName: snootyProjectName,
        _version: version,
        name: sourceName,
        async fetchPages() {
            // TODO: The manifest can be quite large (>100MB) so this could stand to
            // be re-architected to use AsyncGenerators and update page-by-page. For
            // now we can just accept the memory cost.
            const getBranchDocumentsUrl = new URL(`projects/${snootyProjectName}/${currentBranch}/documents`, snootyDataApiBaseUrl);
            const { body } = await (0, node_fetch_1.default)(getBranchDocumentsUrl);
            if (body === null) {
                return [];
            }
            const stream = (0, readline_1.createInterface)(body);
            const linePromises = [];
            const pages = [];
            await new Promise((resolve, reject) => {
                stream.on("line", async (line) => {
                    const entry = JSON.parse(line);
                    switch (entry.type) {
                        case "page": {
                            const { data } = entry;
                            if (data.deleted) {
                                // Page marked deleted by Snooty API. Treat it as if it were not
                                // in the result set at all. The ingest system treats missing
                                // pages as if they have been deleted.
                                return;
                            }
                            return linePromises.push((async () => {
                                try {
                                    const page = await (0, exports.handlePage)(data, {
                                        sourceName,
                                        baseUrl,
                                        tags: tags ?? [],
                                        productName,
                                        version,
                                    });
                                    pages.push(page);
                                }
                                catch (error) {
                                    // Log the error and discard this document, but don't break the
                                    // overall fetchPages() call.
                                    mongodb_rag_core_1.logger.error(`SnootyDataSource handlePage failed with error: ${error?.message}`);
                                }
                            })());
                        }
                        case "asset":
                            // Nothing to do with assets (images...) for now
                            return;
                        case "metadata":
                            // Nothing to do with metadata document for now
                            return;
                        case "timestamp":
                            // Nothing to do with timestamp document for now
                            return;
                        default:
                            return reject(new Error(`unexpected entry type from '${getBranchDocumentsUrl}': ${entry.type}`));
                    }
                });
                stream.on("close", () => {
                    resolve();
                });
            });
            await Promise.allSettled(linePromises);
            return pages;
        },
    };
};
exports.makeSnootyDataSource = makeSnootyDataSource;
const handlePage = async (page, { sourceName, baseUrl, tags: tagsIn = [], productName, version, }) => {
    // Strip first three path segments - according to Snooty team, they'll always
    // be ${property}/docsworker-xlarge/${branch}
    const pagePath = page.page_id
        .split("/")
        .slice(3)
        .filter((segment, i) => {
        // Remove `index` if it's the only segment, as that would create broken links.
        // `index` in subdirectories is fine - Snooty has special case handling for
        // `/index` only.
        return i !== 0 || segment !== "index";
    })
        .join("/");
    const tags = [...tagsIn];
    let body = "";
    let title;
    let format;
    if (page.ast.options?.template === "openapi") {
        format = "openapi-yaml";
        body = await (0, snootyAstToOpenApiSpec_1.snootyAstToOpenApiSpec)(page.ast);
        title = (0, snootyAstToOpenApiSpec_1.getTitleFromSnootyOpenApiSpecAst)(page.ast);
        tags.push("openapi");
    }
    else {
        format = "md";
        body = (0, snootyAstToMd_1.snootyAstToMd)(page.ast);
        title = (0, snootyAstToMd_1.getTitleFromSnootyAst)(page.ast);
    }
    return {
        url: new URL(pagePath, baseUrl.replace(/\/?$/, "/")).href.replace(/\/?$/, // Add trailing slash
        "/"),
        sourceName,
        title,
        body,
        format,
        metadata: {
            tags,
            productName,
            version,
        },
    };
};
exports.handlePage = handlePage;
//# sourceMappingURL=SnootyDataSource.js.map
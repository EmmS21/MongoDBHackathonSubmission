"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rstToSnootyAst = void 0;
const common_tags_1 = require("common-tags");
const docdoctor_1 = require("docdoctor");
const rstToSnootyAst = (rst) => {
    const node = (0, docdoctor_1.parse)(rst);
    // Transform docdoctor/restructured nodes to Snooty AST nodes according to
    // type
    (0, docdoctor_1.visit)(node, (node) => {
        const transform = restructuredToSnootyTypes[node.type];
        if (transform === undefined) {
            return;
        }
        const transforms = Array.isArray(transform) ? transform : [transform];
        transforms.forEach((transform) => {
            Object.assign(node, typeof transform === "string"
                ? { ...node, type: transform }
                : transform(node));
        });
    });
    return node;
};
exports.rstToSnootyAst = rstToSnootyAst;
const stripTargets = (node) => {
    (0, docdoctor_1.visit)(node, (node) => {
        if (node.children === undefined) {
            return;
        }
        let children = node.children
            .map((child) => {
            // Restructured leaves the target in the inner text node: remove it.
            // e.g. `some ref <some-target>`
            return {
                ...child,
                value: child.value?.replace(/\s*<[^>]+>\s*$/, ""),
            };
        })
            .filter((child) => {
            // Remove child nodes that are just targets ("<some-target>")
            return child.value !== "";
        });
        // Trim space from last if needed
        children = children.map((child, i) => {
            return i === children.length - 1
                ? { ...child, value: child.value.replace(/\s+$/, "") }
                : child;
        });
        Object.assign(node, { ...node, children });
    });
    return node;
};
const restructuredToSnootyTypes = {
    document: "root",
    label(node) {
        return {
            type: "target_identifier",
            children: [{ type: "target", children: node.children }],
        };
    },
    directive(nodeIn) {
        const name = nodeIn.directive;
        const node = { ...nodeIn, name };
        if (name === "code-block") {
            const textNodes = (0, docdoctor_1.findAll)(node, ({ value }) => value !== undefined);
            return {
                type: "code",
                lang: node.args,
                value: (0, common_tags_1.stripIndent)(textNodes.map(({ value }) => value).join("\n")),
                directive: undefined,
                children: undefined,
            };
        }
        if (/^tabs.*/.test(name)) {
            return { ...node, name: "tabs" };
        }
        if (name === "tab") {
            // `argument` becomes the tab label
            return { ...node, argument: [{ type: "text", value: node.args }] };
        }
        return node;
    },
    title: "heading",
    interpreted_text: [stripTargets, "ref_role"],
    bullet_list(node) {
        return {
            ...node,
            type: "list",
            enumtype: "unordered",
        };
    },
    list_item: "listItem",
    reference: stripTargets,
    enumerated_list(node) {
        return {
            ...node,
            type: "list",
            enumtype: "arabic",
        };
    },
    text(node) {
        return { ...node, value: node.value.replace(/\n$/, " ") };
    },
};
//# sourceMappingURL=rstToSnootyAst.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeApp = exports.DEFAULT_MAX_REQUEST_TIMEOUT_MS = exports.DEFAULT_API_PREFIX = exports.makeHandleTimeoutMiddleware = exports.reqHandler = exports.errorHandler = void 0;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
require("dotenv/config");
const conversationsRouter_1 = require("./routes/conversations/conversationsRouter");
const mongodb_rag_core_1 = require("mongodb-rag-core");
const utils_1 = require("./utils");
const mongodb_rag_core_2 = require("mongodb-rag-core");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const path_1 = __importDefault(require("path"));
/**
  General error handler. Called at usage of `next()` in routes.
*/
const errorHandler = (err, req, res, _next) => {
    const reqId = (0, utils_1.getRequestId)(req);
    const httpStatus = err.status || 500;
    const errorMessage = err.message || "Internal Server Error";
    if (!res.headersSent) {
        return (0, utils_1.sendErrorResponse)({
            reqId,
            res,
            httpStatus,
            errorMessage,
        });
    }
    else {
        (0, utils_1.logRequest)({
            reqId,
            type: "error",
            message: JSON.stringify(err),
        });
    }
};
exports.errorHandler = errorHandler;
const reqHandler = (req, _res, next) => {
    const reqId = new mongodb_rag_core_1.ObjectId().toString();
    // Custom header specifically for a request ID. This ID will be used to track
    // logs related to the same request
    req.headers["req-id"] = reqId;
    const message = `Request for: ${req.url}`;
    (0, utils_1.logRequest)({ reqId, message });
    next();
};
exports.reqHandler = reqHandler;
const makeHandleTimeoutMiddleware = (apiTimeout) => {
    return (req, res, next) => {
        // Set the server response timeout for all HTTP responses
        res.setTimeout(apiTimeout, () => {
            return (0, utils_1.sendErrorResponse)({
                reqId: req.headers["req-id"],
                res,
                httpStatus: 504,
                errorMessage: "Response timeout",
            });
        });
        next();
    };
};
exports.makeHandleTimeoutMiddleware = makeHandleTimeoutMiddleware;
exports.DEFAULT_API_PREFIX = "/api/v1";
exports.DEFAULT_MAX_REQUEST_TIMEOUT_MS = 60000;
/**
  Constructor function to make the Express.js app.
 */
const makeApp = async (config) => {
    const { maxRequestTimeoutMs = exports.DEFAULT_MAX_REQUEST_TIMEOUT_MS, conversationsRouterConfig, corsOptions, apiPrefix = exports.DEFAULT_API_PREFIX, serveStaticSite, } = config;
    mongodb_rag_core_2.logger.info("Server has the following configuration:");
    mongodb_rag_core_2.logger.info(stringifyFunctions((0, lodash_clonedeep_1.default)(config)));
    const app = (0, express_1.default)();
    app.use((0, exports.makeHandleTimeoutMiddleware)(maxRequestTimeoutMs));
    app.set("trust proxy", true);
    app.use((0, cors_1.default)(corsOptions));
    app.use(express_1.default.json());
    app.use(exports.reqHandler);
    if (serveStaticSite) {
        app.use("/", express_1.default.static(path_1.default.join(__dirname, "..", "static")));
    }
    app.use(`${apiPrefix}/conversations`, (0, conversationsRouter_1.makeConversationsRouter)(conversationsRouterConfig));
    app.get("/health", (_req, res) => {
        const data = {
            uptime: process.uptime(),
            message: "Ok",
            date: new Date(),
        };
        res.status(200).send(data);
    });
    app.all("*", (req, res, _next) => {
        return (0, utils_1.sendErrorResponse)({
            reqId: (0, utils_1.getRequestId)(req),
            res,
            httpStatus: 404,
            errorMessage: "Not Found",
        });
    });
    app.use(exports.errorHandler);
    return app;
};
exports.makeApp = makeApp;
/**
  Helper function to stringify functions when logging the config object.
 */
function stringifyFunctions(obj) {
    if (typeof obj === "function") {
        return obj
            .toString()
            .split("\n")
            .map((line) => line.trim())
            .join("\n");
    }
    // Accept objects and arrays
    if (typeof obj === "object" && obj !== null) {
        const newObj = {};
        for (const key in obj) {
            newObj[key] = stringifyFunctions(obj[key]);
        }
        return newObj;
    }
    return obj;
}
//# sourceMappingURL=app.js.map
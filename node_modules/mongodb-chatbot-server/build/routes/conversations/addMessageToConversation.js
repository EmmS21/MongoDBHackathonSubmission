"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeAddMessageToConversationRoute = exports.AddMessageRequest = exports.AddMessageRequestBody = exports.DEFAULT_MAX_USER_MESSAGES_IN_CONVERSATION = exports.DEFAULT_MAX_INPUT_LENGTH = void 0;
const common_tags_1 = require("common-tags");
const assert_1 = require("assert");
const mongodb_rag_core_1 = require("mongodb-rag-core");
const utils_1 = require("./utils");
const utils_2 = require("../../utils");
const zod_1 = require("zod");
const validateRequestSchema_1 = require("../../middleware/validateRequestSchema");
const filterOnlySystemPrompt_1 = require("../../processors/filterOnlySystemPrompt");
const generateResponse_1 = require("../generateResponse");
exports.DEFAULT_MAX_INPUT_LENGTH = 300; // magic number for max input size for LLM
exports.DEFAULT_MAX_USER_MESSAGES_IN_CONVERSATION = 7; // magic number for max messages in a conversation
exports.AddMessageRequestBody = zod_1.z.object({
    message: zod_1.z.string(),
});
exports.AddMessageRequest = validateRequestSchema_1.SomeExpressRequest.merge(zod_1.z.object({
    headers: zod_1.z.object({
        "req-id": zod_1.z.string(),
    }),
    params: zod_1.z.object({
        conversationId: zod_1.z.string(),
    }),
    query: zod_1.z.object({
        stream: zod_1.z.string().optional(),
    }),
    body: exports.AddMessageRequestBody,
}));
function makeAddMessageToConversationRoute({ conversations, llm, dataStreamer, generateUserPrompt, maxInputLengthCharacters = exports.DEFAULT_MAX_INPUT_LENGTH, maxUserMessagesInConversation = exports.DEFAULT_MAX_USER_MESSAGES_IN_CONVERSATION, filterPreviousMessages = filterOnlySystemPrompt_1.filterOnlySystemPrompt, addMessageToConversationCustomData, }) {
    return async (req, res) => {
        const reqId = (0, utils_2.getRequestId)(req);
        try {
            const { params: { conversationId: conversationIdString }, body: { message }, query: { stream }, ip, } = req;
            (0, utils_2.logRequest)({
                reqId,
                message: (0, common_tags_1.stripIndents) `Request info:
          User message: ${message}
          Stream: ${stream}
          IP: ${ip}
          ConversationId: ${conversationIdString}`,
            });
            const latestMessageText = message;
            if (latestMessageText.length > maxInputLengthCharacters) {
                throw (0, utils_1.makeRequestError)({
                    httpStatus: 400,
                    message: "Message too long",
                });
            }
            const customData = await getCustomData({
                req,
                res,
                addMessageToConversationCustomData,
            });
            // --- LOAD CONVERSATION ---
            const conversation = await loadConversation({
                conversationIdString,
                conversations,
            });
            // --- MAX CONVERSATION LENGTH CHECK ---
            const numUserMessages = conversation.messages.reduce((acc, message) => (message.role === "user" ? acc + 1 : acc), 0);
            if (numUserMessages >= maxUserMessagesInConversation) {
                // Omit the system prompt and assume the user always received one response per message
                throw (0, utils_1.makeRequestError)({
                    httpStatus: 400,
                    message: `Too many messages. You cannot send more than ${maxUserMessagesInConversation} messages in this conversation.`,
                });
            }
            // --- DETERMINE IF SHOULD STREAM ---
            const shouldStream = Boolean(stream);
            // --- GENERATE USER MESSAGE ---
            const { userMessage, references, rejectQuery } = await (generateUserPrompt
                ? generateUserPrompt({
                    userMessageText: latestMessageText,
                    conversation,
                    reqId,
                    customData,
                })
                : {
                    userMessage: {
                        role: "user",
                        content: latestMessageText,
                        customData,
                    },
                });
            // Add request custom data to user message.
            const userMessageWithCustomData = customData
                ? {
                    ...userMessage,
                    // Override request custom data fields with user message custom data fields.
                    customData: { ...customData, ...(userMessage.customData ?? {}) },
                }
                : userMessage;
            const newMessages = [userMessageWithCustomData];
            if (rejectQuery) {
                const rejectionMessage = {
                    role: "assistant",
                    content: conversations.conversationConstants.NO_RELEVANT_CONTENT,
                    references: references ?? [],
                };
                const messages = [...newMessages, rejectionMessage];
                sendStaticNonResponse({
                    conversations,
                    conversation,
                    shouldStream,
                    dataStreamer,
                    res,
                    messages,
                });
            }
            else {
                const llmConversation = [
                    ...(await filterPreviousMessages(conversation)).map(convertConversationMessageToLlmMessage),
                    ...newMessages.map((m) => {
                        // Use transformed content if it exists for user message,
                        // otherwise use original content.
                        if (m.role === "user") {
                            return {
                                content: m.contentForLlm ?? m.content,
                                role: "user",
                            };
                        }
                        return convertConversationMessageToLlmMessage(m);
                    }),
                ];
                // --- GENERATE RESPONSE ---
                if (shouldStream) {
                    dataStreamer.connect(res);
                }
                const { messages: generatedMessages } = await (0, generateResponse_1.generateResponse)({
                    shouldStream,
                    llm,
                    llmConversation,
                    dataStreamer,
                    references,
                    reqId,
                    llmNotWorkingMessage: conversations.conversationConstants.LLM_NOT_WORKING,
                    noRelevantContentMessage: conversations.conversationConstants.NO_RELEVANT_CONTENT,
                    request: req,
                });
                // --- SAVE QUESTION & RESPONSE ---
                const dbNewMessages = await addMessagesToDatabase({
                    conversations,
                    conversation,
                    messages: [
                        ...newMessages,
                        ...generatedMessages.map((m) => (0, generateResponse_1.convertMessageFromLlmToDb)(m)),
                    ],
                });
                const dbAssistantMessage = dbNewMessages[dbNewMessages.length - 1];
                (0, assert_1.strict)(dbAssistantMessage !== undefined, "No assistant message found");
                const apiRes = (0, utils_1.convertMessageFromDbToApi)(dbAssistantMessage);
                if (!shouldStream) {
                    return res.status(200).json(apiRes);
                }
                else {
                    dataStreamer.streamData({
                        type: "finished",
                        data: apiRes.id,
                    });
                }
            }
        }
        catch (error) {
            const { httpStatus, message } = error.name === "RequestError"
                ? error
                : (0, utils_1.makeRequestError)({
                    message: error.message,
                    stack: error.stack,
                    httpStatus: 500,
                });
            (0, utils_2.sendErrorResponse)({
                res,
                reqId,
                httpStatus,
                errorMessage: message,
            });
        }
        finally {
            if (dataStreamer.connected) {
                dataStreamer.disconnect();
            }
        }
    };
}
exports.makeAddMessageToConversationRoute = makeAddMessageToConversationRoute;
// --- HELPERS ---
async function getCustomData({ req, res, addMessageToConversationCustomData, }) {
    try {
        return addMessageToConversationCustomData
            ? await addMessageToConversationCustomData(req, res)
            : undefined;
    }
    catch (_err) {
        throw (0, utils_1.makeRequestError)({
            httpStatus: 500,
            message: "Unable to process custom data",
        });
    }
}
async function sendStaticNonResponse({ conversations, conversation, messages, shouldStream, dataStreamer, res, }) {
    const dbMessages = await addMessagesToDatabase({
        conversations,
        conversation,
        messages,
    });
    const assistantMessage = dbMessages.pop();
    (0, assert_1.strict)(assistantMessage !== undefined && assistantMessage.role === "assistant", "No assistant message found");
    const apiRes = (0, utils_1.convertMessageFromDbToApi)(assistantMessage);
    if (shouldStream) {
        dataStreamer.connect(res);
        dataStreamer.streamData({
            type: "delta",
            data: apiRes.content,
        });
        dataStreamer.streamData({
            type: "finished",
            data: apiRes.id,
        });
        dataStreamer.disconnect();
        return;
    }
    else {
        return res.status(200).json(apiRes);
    }
}
function convertConversationMessageToLlmMessage(message) {
    const { content, role } = message;
    if (role === "system") {
        return {
            content: content,
            role: "system",
        };
    }
    if (role === "function") {
        return {
            content: content,
            role: "function",
            name: message.name,
        };
    }
    if (role === "user") {
        return {
            content: content,
            role: "user",
        };
    }
    if (role === "assistant") {
        return {
            content: content,
            role: "assistant",
            ...(message.functionCall ? { functionCall: message.functionCall } : {}),
        };
    }
    throw new Error(`Invalid message role: ${role}`);
}
async function addMessagesToDatabase({ conversation, conversations, messages, }) {
    const conversationId = conversation._id;
    const dbMessages = await conversations.addManyConversationMessages({
        conversationId,
        messages,
    });
    return dbMessages;
}
const loadConversation = async ({ conversationIdString, conversations, }) => {
    const conversationId = toObjectId(conversationIdString);
    const conversation = await conversations.findById({
        _id: conversationId,
    });
    if (!conversation) {
        throw (0, utils_1.makeRequestError)({
            httpStatus: 404,
            message: `Conversation ${conversationId} not found`,
        });
    }
    return conversation;
};
const toObjectId = (id) => {
    try {
        return new mongodb_rag_core_1.ObjectId(id);
    }
    catch (error) {
        throw (0, utils_1.makeRequestError)({
            httpStatus: 400,
            message: `Invalid ObjectId string: ${id}`,
        });
    }
};
//# sourceMappingURL=addMessageToConversation.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRequestError = exports.areEquivalentIpAddresses = exports.isValidIp = exports.convertConversationFromDbToApi = exports.convertMessageFromDbToApi = exports.ApiConversation = exports.ApiMessage = void 0;
const net_1 = require("net");
const ip_address_1 = require("ip-address");
const mongodb_rag_core_1 = require("mongodb-rag-core");
const zod_1 = require("zod");
exports.ApiMessage = zod_1.z.object({
    id: zod_1.z.string(),
    role: zod_1.z.enum(["system", "assistant", "user", "function"]),
    content: zod_1.z.string(),
    rating: zod_1.z.boolean().optional(),
    createdAt: zod_1.z.number(),
    references: mongodb_rag_core_1.References.optional(),
});
exports.ApiConversation = zod_1.z.object({
    _id: zod_1.z.string(),
    messages: zod_1.z.array(exports.ApiMessage),
    createdAt: zod_1.z.number(),
});
function convertMessageFromDbToApi(message) {
    const { id, createdAt, role, content } = message;
    const apiMessage = {
        id: id.toString(),
        role,
        content,
        createdAt: createdAt.getTime(),
    };
    if (role === "assistant") {
        const { rating, references } = message;
        return {
            ...apiMessage,
            rating,
            references,
        };
    }
    return apiMessage;
}
exports.convertMessageFromDbToApi = convertMessageFromDbToApi;
function assertNever(x) {
    throw new Error("Unexpected object: " + x);
}
function isMessageAllowedInApiResponse(message) {
    // Only return user messages and assistant messages that are not function calls
    switch (message.role) {
        case "system":
            return false;
        case "user":
            return true;
        case "assistant":
            return message.functionCall === undefined;
        case "function":
            return false;
        default:
            // This should never happen - it means we missed a case in the switch.
            // The assertNever function raises a type error if this happens.
            return assertNever(message);
    }
}
function convertConversationFromDbToApi(conversation) {
    return {
        _id: conversation._id.toHexString(),
        createdAt: conversation.createdAt.getTime(),
        messages: conversation.messages
            .filter(isMessageAllowedInApiResponse)
            .map(convertMessageFromDbToApi),
    };
}
exports.convertConversationFromDbToApi = convertConversationFromDbToApi;
function isValidIp(ip) {
    return ip !== undefined && (0, net_1.isIP)(ip) > 0;
}
exports.isValidIp = isValidIp;
function areEquivalentIpAddresses(ip1, ip2) {
    if (ip_address_1.Address6.isValid(ip1)) {
        ip1 = new ip_address_1.Address6(ip1).to4().correctForm();
    }
    if (ip_address_1.Address6.isValid(ip2)) {
        ip2 = new ip_address_1.Address6(ip2).to4().correctForm();
    }
    return ip1 === ip2;
}
exports.areEquivalentIpAddresses = areEquivalentIpAddresses;
const makeRequestError = ({ message, httpStatus, stack: stackIn, }) => {
    const stack = stackIn ?? new Error(message).stack;
    return {
        stack,
        message,
        httpStatus,
        name: "RequestError",
    };
};
exports.makeRequestError = makeRequestError;
//# sourceMappingURL=utils.js.map
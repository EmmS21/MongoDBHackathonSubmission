"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.getInnerText = void 0;
var restructured_1 = __importDefault(require("restructured"));
var tree_1 = require("./tree");
var assert_1 = require("assert");
var getInnerText = function (node) {
    return (0, tree_1.findAll)(node, function (node) { return node.type === "text"; })
        .map(function (node) { return node.value; })
        .join("");
};
exports.getInnerText = getInnerText;
// Wrapper that handles directives. WARNING: Line, columns, and indent may not
// be 100% accurate.
var parse = function (rst, options) {
    var _a;
    var depth = (_a = options === null || options === void 0 ? void 0 : options.depth) !== null && _a !== void 0 ? _a : 0;
    var root = restructured_1.default.parse(rst, __assign(__assign({}, options), { position: true, indent: true }));
    // Parse directives
    (0, tree_1.visit)(root, function () {
        // Do nothing on enter because we'll be actively modifying the tree during
        // this visit and don't want to visit the new nodes.
    }, function (node) {
        if (node.type !== "directive") {
            return;
        }
        // See
        // https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#directives
        // for details.
        var directiveNode = __assign(__assign({}, node), { type: "directive", directive: node.directive });
        // IIFE to ensure we can exit the next block early and still assign
        // whatever result to the node object
        (function () {
            // Note: Restructured library does not provide accurate positions for
            // directive inner text nodes. It also doesn't provide access to blank lines
            // between the options list and the content body. So, separating the args,
            // options and content is all more complicated than it would otherwise be.
            var _a;
            // Extract args node if any
            while (((_a = node.children[0]) === null || _a === void 0 ? void 0 : _a.position.start.line) === node.position.start.line) {
                var argsNode = node.children.shift();
                var argValue = argsNode.value.trim();
                (0, assert_1.strict)(argsNode.type === "text");
                directiveNode.args =
                    directiveNode.args === undefined
                        ? argValue
                        : "".concat(directiveNode.args, " ").concat(argValue);
            }
            if (node.children.length === 0) {
                // No options or content (but might have argument)
                return;
            }
            var _b = getBody({ node: node, rst: rst }), bodyPosition = _b.bodyPosition, bodyLines = _b.bodyLines;
            // Track the length of the option section for position adjustment later
            var optionSectionLength = 0;
            var indent = node.indent;
            (0, assert_1.strict)(indent !== undefined);
            while (bodyLines.length > 0) {
                var topLine = bodyLines.shift();
                optionSectionLength += (topLine + "\n").length;
                if (topLine.trim() === "") {
                    // Blank line indicates end of options and start of content
                    break;
                }
                if (directiveNode.optionLines === undefined) {
                    directiveNode.optionLines = [];
                }
                // Add deindented line to option lines
                directiveNode.optionLines.push(topLine.substring(indent.width));
            }
            // Remaining body lines are content lines
            var parsedContent = (0, exports.parse)(bodyLines.join("\n"), __assign(__assign({}, options), { depth: depth + 1 })).children;
            // Skip down from top-level "document" to fake "block quote" node
            // (because directive body is indented). Only the child nodes of
            // parsedContent will be kept.
            if (!parsedContent || parsedContent.length === 0) {
                // Maybe options and args but no content
                directiveNode.children = [];
                return;
            }
            // Adjust the inner parse job's positions relative to the parent rST document
            var children = parsedContent
                .map(function (parsedContent) {
                (0, tree_1.visit)(parsedContent, function (node) {
                    if (node === parsedContent) {
                        // Skip the top-level node, as it will be discarded anyway
                        return;
                    }
                    var _a = node.position, start = _a.start, end = _a.end;
                    var newOffset = start.offset + bodyPosition.start.offset + optionSectionLength;
                    node.position = {
                        start: __assign(__assign({}, start), { offset: newOffset, line: start.line + bodyPosition.start.line, column: start.column + indent.offset }),
                        end: __assign(__assign({}, end), { offset: end.offset +
                                bodyPosition.start.offset +
                                optionSectionLength, line: end.line + bodyPosition.start.line, column: end.column + indent.offset }),
                    };
                });
                return parsedContent.children;
            })
                .flat(1);
            directiveNode.children = children;
        })();
        Object.assign(node, directiveNode);
    });
    // Assign 'target' to refroles and doclinks
    (0, tree_1.findAll)(root, function (node) {
        return node.type === "interpreted_text" &&
            ["doc", "ref"].includes(node.role);
    }).forEach(function (node) {
        var _a;
        var text = (0, exports.getInnerText)(node);
        var matches = /^.*<(.*)>\s*$/m.exec(text);
        // If no matches, then no title -- just ref label -- e.g. :ref:`some-label`
        node.target = (_a = (matches && matches[1])) !== null && _a !== void 0 ? _a : text;
    });
    // Find labels
    (0, tree_1.findAll)(root, function (node) { return node.type === "comment"; }).forEach(function (node) {
        var text = (0, exports.getInnerText)(node);
        var matches = /^_(.*):$/.exec(text);
        if (matches === null) {
            return;
        }
        node.type = "label";
        node.label = matches[1];
    });
    // Find references (links)
    (0, tree_1.findAll)(root, function (node) { return node.type === "reference"; }).forEach(function (node) {
        var _a;
        var text = (0, exports.getInnerText)(node);
        var matches = /^.*<(.*)>\s*$/m.exec(text);
        if (matches === null) {
            return;
        }
        node.target = (_a = (matches && matches[1])) !== null && _a !== void 0 ? _a : text;
    });
    return root;
};
exports.parse = parse;
function getBody(_a) {
    var rst = _a.rst, node = _a.node;
    // Reconstruct the directive body (including options and content). Start at
    // directive start, then adjust by peeling off the first line (directive +
    // maybe arg).
    var bodyPosition = {
        end: __assign({}, node.children[node.children.length - 1].position.end),
        start: __assign({}, node.position.start),
    };
    var rawText = rst.substring(bodyPosition.start.offset, bodyPosition.end.offset);
    var bodyLines = rawText.split("\n");
    bodyPosition.start.line += 1;
    bodyPosition.start.column = 1;
    bodyPosition.start.offset += bodyLines[0].length + 1;
    bodyLines.shift();
    return { bodyLines: bodyLines, bodyPosition: bodyPosition };
}
exports.default = { parse: exports.parse };

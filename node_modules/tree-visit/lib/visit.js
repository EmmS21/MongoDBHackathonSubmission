"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visit = exports.STOP = exports.SKIP = void 0;
exports.SKIP = 'skip';
exports.STOP = 'stop';
/**
 * Visit each node in the tree, calling an optional `onEnter` and `onLeave` for each.
 *
 * From `onEnter`:
 *
 * - return nothing or `undefined` to continue
 * - return `"skip"` to skip the children of that node and the subsequent `onLeave`
 * - return `"stop"` to end traversal
 *
 * From `onLeave`:
 *
 * - return nothing or `undefined` to continue
 * - return `"stop"` to end traversal
 */
function visit(node, options) {
    var _a, _b;
    const normalizedOptions = Object.assign(Object.assign({}, options), { onEnter: (_a = options.onEnter) !== null && _a !== void 0 ? _a : (() => { }), onLeave: (_b = options.onLeave) !== null && _b !== void 0 ? _b : (() => { }) });
    visitInternal(node, normalizedOptions);
}
exports.visit = visit;
function visitInternal(root, options) {
    const { onEnter, onLeave, getChildren } = options;
    let indexPath = [];
    let stack = [{ node: root }];
    while (stack.length > 0) {
        let wrapper = stack[stack.length - 1];
        // Visit the wrapped node
        if (wrapper.state === undefined) {
            const enterResult = onEnter(wrapper.node, indexPath);
            if (enterResult === exports.STOP)
                return enterResult;
            wrapper.state = enterResult === exports.SKIP ? -1 : 0;
        }
        const children = wrapper.children || getChildren(wrapper.node, indexPath);
        if (!wrapper.children) {
            wrapper.children = children;
        }
        // If the node wasn't skipped
        if (wrapper.state !== -1) {
            // Visit the next child
            if (wrapper.state < children.length) {
                let currentIndex = wrapper.state;
                indexPath.push(currentIndex);
                stack.push({ node: children[currentIndex] });
                wrapper.state = currentIndex + 1;
                continue;
            }
            const leaveResult = onLeave(wrapper.node, indexPath);
            if (leaveResult === exports.STOP)
                return leaveResult;
        }
        indexPath.pop();
        stack.pop();
    }
}

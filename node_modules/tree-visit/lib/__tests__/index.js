"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const access_1 = require("../access");
const diagram_1 = require("../diagram");
const find_1 = require("../find");
const flat_1 = require("../flat");
const flatMap_1 = require("../flatMap");
const index_1 = require("../index");
const map_1 = require("../map");
const reduce_1 = require("../reduce");
const withOptions_1 = require("../withOptions");
function getChildren(node) {
    var _a;
    return (_a = node.children) !== null && _a !== void 0 ? _a : [];
}
// Create a new child object for each node to test that we're not relying on object identity
function getChildrenUnstable(node) {
    return getChildren(node).map((item) => (Object.assign({}, item)));
}
const example = {
    name: 'a',
    children: [
        {
            name: 'b',
            indexPath: [0],
            children: [
                { name: 'b1', indexPath: [0, 0] },
                { name: 'b2', indexPath: [0, 1] },
            ],
        },
        {
            name: 'c',
            indexPath: [1],
            children: [
                { name: 'c1', indexPath: [1, 0] },
                { name: 'c2', indexPath: [1, 1] },
            ],
        },
    ],
    indexPath: [],
};
function getTypedChildren(typedNode) {
    return getChildren(typedNode).map((item) => (Object.assign({ type: 'b' }, item)));
}
const typedExample = Object.assign({ type: 'a' }, example);
function createNestedNode(depth) {
    var _a;
    let count = 0;
    let root = { name: `${count++}`, indexPath: [], children: [] };
    let current = root;
    for (let i = 0; i < depth - 1; i++) {
        let child = {
            name: `${count++}`,
            indexPath: [...current.indexPath, 0],
            children: [],
        };
        (_a = current.children) === null || _a === void 0 ? void 0 : _a.push(child);
        current = child;
    }
    return root;
}
it('traverses normally', () => {
    let enterNames = [];
    let leaveNames = [];
    let getChildrenCount = 0;
    let countGetChildren = (node) => {
        getChildrenCount++;
        return getChildren(node);
    };
    (0, index_1.visit)(example, {
        onEnter: (child, indexPath) => {
            expect(indexPath).toEqual(child.indexPath);
            enterNames.push(child.name);
        },
        onLeave: (child, indexPath) => {
            expect(indexPath).toEqual(child.indexPath);
            leaveNames.push(child.name);
        },
        getChildren: countGetChildren,
    });
    expect(getChildrenCount).toEqual(7);
    expect(enterNames).toEqual(['a', 'b', 'b1', 'b2', 'c', 'c1', 'c2']);
    expect(leaveNames).toEqual(['b1', 'b2', 'b', 'c1', 'c2', 'c', 'a']);
});
it('traverses deeply nested nodes', () => {
    let enterNames = [];
    const nestedNode = createNestedNode(6000);
    (0, index_1.visit)(nestedNode, {
        onEnter: (child) => {
            enterNames.push(child.name);
        },
        getChildren,
    });
    expect(enterNames.length).toEqual(6000);
});
it('skips in onEnter', () => {
    let enterNames = [];
    let leaveNames = [];
    (0, index_1.visit)(example, {
        onEnter: (child) => {
            enterNames.push(child.name);
            if (child.name === 'b')
                return 'skip';
        },
        onLeave: (child) => {
            leaveNames.push(child.name);
        },
        getChildren,
    });
    expect(enterNames).toEqual(['a', 'b', 'c', 'c1', 'c2']);
    expect(leaveNames).toEqual(['c1', 'c2', 'c', 'a']);
});
it('stops in onEnter', () => {
    let enterNames = [];
    let leaveNames = [];
    (0, index_1.visit)(example, {
        onEnter: (child) => {
            enterNames.push(child.name);
            if (child.name === 'b')
                return 'stop';
        },
        onLeave: (child) => {
            leaveNames.push(child.name);
        },
        getChildren,
    });
    expect(enterNames).toEqual(['a', 'b']);
    expect(leaveNames).toEqual([]);
});
it('stops in onLeave', () => {
    let enterNames = [];
    let leaveNames = [];
    (0, index_1.visit)(example, {
        onEnter: (child) => {
            enterNames.push(child.name);
        },
        onLeave: (child) => {
            leaveNames.push(child.name);
            if (child.name === 'b')
                return 'stop';
        },
        getChildren,
    });
    expect(enterNames).toEqual(['a', 'b', 'b1', 'b2']);
    expect(leaveNames).toEqual(['b1', 'b2', 'b']);
});
describe('access', () => {
    it('accesses node at index path', () => {
        (0, index_1.visit)(example, {
            onEnter: (child, indexPath) => {
                const found = (0, access_1.access)(example, indexPath, { getChildren });
                expect(found.name).toEqual(child.name);
            },
            getChildren,
        });
    });
    it('accesses node path', () => {
        expect((0, access_1.accessPath)(example, [0, 1], { getChildren }).map((node) => node.name)).toEqual(['a', 'b', 'b2']);
    });
});
describe('find', () => {
    it('finds a node', () => {
        const node = (0, find_1.find)(example, {
            getChildren,
            predicate: (node) => node.name === 'b1',
        });
        expect(node === null || node === void 0 ? void 0 : node.name).toEqual('b1');
    });
    it('finds a typed node', () => {
        const node = (0, find_1.find)(typedExample, {
            getChildren: getTypedChildren,
            predicate: (node) => node.type === 'a',
        });
        // This will throw a compiler error if not working correctly
        expect(node && node.type === 'a').toEqual(true);
    });
    it('finds all nodes', () => {
        const nodes = (0, find_1.findAll)(example, {
            getChildren,
            predicate: (node) => node.name.startsWith('b'),
        });
        expect(nodes.map((node) => node.name)).toEqual(['b', 'b1', 'b2']);
    });
    it('finds all typed nodes', () => {
        const nodes = (0, find_1.findAll)(typedExample, {
            getChildren: getTypedChildren,
            predicate: (node) => node.type === 'a',
        });
        // This will throw a compiler error if not working correctly
        expect(nodes[0].type === 'a').toEqual(true);
    });
    it('finds a node index path', () => {
        const indexPath = (0, find_1.findIndexPath)(example, {
            getChildren,
            predicate: (node, indexPath) => indexPath.join() === [0, 1].join(),
        });
        expect(indexPath).toEqual([0, 1]);
    });
    it('finds all node index paths', () => {
        const indexPaths = (0, find_1.findAllIndexPaths)(example, {
            getChildren,
            predicate: (node) => node.name.startsWith('b'),
        });
        expect(indexPaths).toEqual([[0], [0, 0], [0, 1]]);
        const nodes = indexPaths.map((indexPath) => (0, access_1.access)(example, indexPath, { getChildren }));
        expect(nodes.map((node) => node.name)).toEqual(['b', 'b1', 'b2']);
    });
});
describe('flat', () => {
    it('flattens a tree', () => {
        const nodes = (0, flat_1.flat)(example, {
            getChildren,
        });
        expect(nodes.map((node) => node.name)).toEqual([
            'a',
            'b',
            'b1',
            'b2',
            'c',
            'c1',
            'c2',
        ]);
    });
});
describe('flatMap', () => {
    it('flatMaps a tree', () => {
        const items = (0, flatMap_1.flatMap)(example, {
            getChildren,
            transform: (node) => [{ name: node.name, depth: node.indexPath.length }],
        });
        expect(items).toEqual([
            { depth: 0, name: 'a' },
            { depth: 1, name: 'b' },
            { depth: 2, name: 'b1' },
            { depth: 2, name: 'b2' },
            { depth: 1, name: 'c' },
            { depth: 2, name: 'c1' },
            { depth: 2, name: 'c2' },
        ]);
    });
});
describe('reduce', () => {
    it('reduces a tree', () => {
        const result = (0, reduce_1.reduce)(example, {
            getChildren,
            initialResult: 0,
            nextResult: (result) => result + 1,
        });
        expect(result).toEqual(7);
    });
});
describe('map', () => {
    it('maps a tree', () => {
        const result = (0, map_1.map)(example, {
            getChildren,
            transform: (node, children) => ({
                id: node.name,
                items: children,
            }),
        });
        expect((0, flat_1.flat)(result, {
            getChildren: (node) => node.items,
        }).map((node) => node.id)).toEqual(['a', 'b', 'b1', 'b2', 'c', 'c1', 'c2']);
    });
    it('maps a tree and omits nodes', () => {
        const result = (0, map_1.map)(example, {
            getChildren,
            transform: (node, children) => ({
                id: node.name,
                items: children.filter((child) => child.id !== 'b1' && child.id !== 'c'),
            }),
        });
        expect((0, flat_1.flat)(result, {
            getChildren: (node) => node.items,
        }).map((node) => node.id)).toEqual(['a', 'b', 'b2']);
    });
    it('maps a tree with unstable object identity', () => {
        const result = (0, map_1.map)(example, {
            getChildren: getChildrenUnstable,
            transform: (node, children) => ({
                id: node.name,
                items: children,
            }),
        });
        expect((0, flat_1.flat)(result, {
            getChildren: (node) => node.items,
        }).map((node) => node.id)).toEqual(['a', 'b', 'b1', 'b2', 'c', 'c1', 'c2']);
    });
});
describe('diagram', () => {
    const getLabel = (node) => node.name;
    const getMultilineLabel = (node) => `name: ${node.name}\npath: ${node.indexPath.join('.')}`;
    it('generates folder diagram', () => {
        expect((0, diagram_1.diagram)(example, { getChildren, getLabel })).toMatchSnapshot();
        expect((0, diagram_1.diagram)(example, { getChildren, getLabel, flattenSingleChildNodes: true })).toMatchSnapshot();
    });
    it('generates folder diagram with single child case', () => {
        const singleChild = {
            name: 'a',
            children: [
                {
                    name: 'b',
                    indexPath: [0],
                    children: [{ name: 'b1', indexPath: [0, 0] }],
                },
            ],
            indexPath: [],
        };
        expect((0, diagram_1.diagram)(singleChild, { getChildren, getLabel })).toMatchSnapshot();
        expect((0, diagram_1.diagram)(singleChild, {
            getChildren,
            getLabel,
            flattenSingleChildNodes: true,
        })).toMatchSnapshot();
    });
    it('generates folder diagram with non-root single child case', () => {
        const singleChild = {
            name: 'a',
            children: [
                {
                    name: 'b',
                    indexPath: [0],
                    children: [{ name: 'b1', indexPath: [0, 0] }],
                },
                {
                    name: 'c',
                    indexPath: [1],
                    children: [{ name: 'c1', indexPath: [1, 0] }],
                },
            ],
            indexPath: [],
        };
        expect((0, diagram_1.diagram)(singleChild, { getChildren, getLabel })).toMatchSnapshot();
        expect((0, diagram_1.diagram)(singleChild, {
            getChildren,
            getLabel,
            flattenSingleChildNodes: true,
        })).toMatchSnapshot();
    });
    it('generates folder diagram with hidden root', () => {
        const singleChild = {
            name: '',
            children: [
                {
                    name: 'b',
                    indexPath: [0],
                    children: [{ name: 'b1', indexPath: [0, 0] }],
                },
            ],
            indexPath: [],
        };
        expect((0, diagram_1.diagram)(singleChild, { getChildren, getLabel })).toMatchSnapshot();
        expect((0, diagram_1.diagram)(singleChild, {
            getChildren,
            getLabel,
            flattenSingleChildNodes: true,
        })).toMatchSnapshot();
    });
    it('generates folder diagram with multiline label', () => {
        expect((0, diagram_1.diagram)(example, { getChildren, getLabel: getMultilineLabel })).toMatchSnapshot();
        expect((0, diagram_1.diagram)(example, {
            getChildren,
            getLabel: getMultilineLabel,
            flattenSingleChildNodes: true,
        })).toMatchSnapshot();
    });
    it('generates folder diagram with multiline label and single child case', () => {
        const singleChild = {
            name: 'a',
            children: [
                {
                    name: 'b',
                    indexPath: [0],
                    children: [{ name: 'b1', indexPath: [0, 0] }],
                },
            ],
            indexPath: [],
        };
        expect((0, diagram_1.diagram)(singleChild, { getChildren, getLabel: getMultilineLabel })).toMatchSnapshot();
        expect((0, diagram_1.diagram)(singleChild, { getChildren, getLabel: getMultilineLabel })).toMatchSnapshot();
    });
    it('generates box diagram', () => {
        expect((0, diagram_1.diagram)(example, { type: 'box', getChildren, getLabel })).toMatchSnapshot();
    });
    it('generates multiline box diagram', () => {
        expect((0, diagram_1.diagram)(example, {
            type: 'box',
            getChildren,
            getLabel: (node) => node.name === 'b'
                ? `name: ${node.name}\npath: ${node.indexPath.join('.')}`
                : `name: ${node.name}`,
        })).toMatchSnapshot();
    });
    it('generates uneven box diagram', () => {
        const node = {
            name: 'a',
            children: [
                {
                    name: 'hello',
                    indexPath: [0],
                },
                {
                    name: 'c',
                    indexPath: [1],
                },
            ],
            indexPath: [],
        };
        expect((0, diagram_1.diagram)(node, { type: 'box', getChildren, getLabel })).toMatchSnapshot();
    });
    it('generates single child box', () => {
        const node = {
            name: 'a',
            children: [
                {
                    name: 'okay',
                    indexPath: [0],
                },
            ],
            indexPath: [],
        };
        expect((0, diagram_1.diagram)(node, { type: 'box', getChildren, getLabel })).toMatchSnapshot();
    });
});
describe('withOptions', () => {
    it('binds options', () => {
        var _a;
        const { find, access, visit, reduce, flatMap, map } = (0, withOptions_1.withOptions)({
            getChildren,
        });
        let enterNames = [];
        visit(example, {
            onEnter: (child) => {
                enterNames.push(child.name);
            },
        });
        expect(enterNames).toEqual(['a', 'b', 'b1', 'b2', 'c', 'c1', 'c2']);
        expect((_a = find(example, {
            predicate: (node) => node.name === 'b1',
        })) === null || _a === void 0 ? void 0 : _a.name).toEqual('b1');
        expect(access(example, [0, 0]).name).toEqual('b1');
        expect(reduce(example, (result, node) => (result ? result + ' ' + node.name : node.name), '')).toEqual('a b b1 b2 c c1 c2');
        expect(flatMap(example, (node) => node.name.split(''))).toEqual([
            'a',
            'b',
            'b',
            '1',
            'b',
            '2',
            'c',
            'c',
            '1',
            'c',
            '2',
        ]);
        expect(map(example, (node, transformedChildren) => ({
            id: `${node.name}:${transformedChildren.length}`,
        })).id).toEqual('a:2');
    });
    it('supports typed finding', () => {
        var _a, _b;
        const { find, findAll } = (0, withOptions_1.withOptions)({ getChildren: getTypedChildren });
        expect(((_a = find(typedExample, {
            predicate: (node) => node.type === 'a',
        })) === null || _a === void 0 ? void 0 : _a.type) === 'a').toEqual(true);
        expect(((_b = findAll(typedExample, {
            predicate: (node) => node.type === 'a',
        })[0]) === null || _b === void 0 ? void 0 : _b.type) === 'a').toEqual(true);
    });
    it('supports overloaded calls', () => {
        var _a;
        const { find, findAllIndexPaths, visit, diagram, flat } = (0, withOptions_1.withOptions)({
            getChildren,
        });
        let enterNames = [];
        visit(example, (child) => {
            enterNames.push(child.name);
        });
        expect(enterNames).toEqual(['a', 'b', 'b1', 'b2', 'c', 'c1', 'c2']);
        expect(flat(example).map((node) => node.name)).toEqual([
            'a',
            'b',
            'b1',
            'b2',
            'c',
            'c1',
            'c2',
        ]);
        expect((_a = find(example, (node) => node.name === 'b1')) === null || _a === void 0 ? void 0 : _a.name).toEqual('b1');
        expect(findAllIndexPaths(example, (node) => node.name.startsWith('b'))).toEqual([[0], [0, 0], [0, 1]]);
        expect(diagram(example, (node) => node.name)).toMatchSnapshot();
        expect(diagram(example, {
            getLabel: (node) => node.name,
        })).toMatchSnapshot();
    });
});

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixBlock = exports.isMultiline = exports.directoryDiagram = void 0;
var LinePrefix;
(function (LinePrefix) {
    LinePrefix["Child"] = "\u251C\u2500\u2500 ";
    LinePrefix["LastChild"] = "\u2514\u2500\u2500 ";
    LinePrefix["NestedChild"] = "\u2502   ";
    LinePrefix["LastNestedChild"] = "    ";
})(LinePrefix || (LinePrefix = {}));
function nodeDiagram(node, indexPath, options) {
    const label = options.getLabel(node, indexPath);
    const depth = indexPath.length;
    let rootLine = { label, depth, prefix: '', multilinePrefix: '' };
    const children = options.getChildren(node, indexPath);
    if (children.length === 0)
        return [rootLine];
    // Special-case nodes with a single child, collapsing their labels to a single line
    if (options.flattenSingleChildNodes &&
        children.length === 1 &&
        !isMultiline(label)) {
        const [line] = nodeDiagram(children[0], [...indexPath, 0], options);
        const hideRoot = indexPath.length === 0 && label === '';
        rootLine.label = hideRoot
            ? `/ ${line.label}`
            : `${rootLine.label} / ${line.label}`;
        return [rootLine];
    }
    const nestedLines = children.flatMap((file, index, array) => {
        const childIsLast = index === array.length - 1;
        const childLines = nodeDiagram(file, [...indexPath, index], options);
        const childPrefix = childIsLast ? LinePrefix.LastChild : LinePrefix.Child;
        const childMultilinePrefix = childIsLast
            ? LinePrefix.LastNestedChild
            : LinePrefix.NestedChild;
        childLines.forEach((line) => {
            if (line.depth === depth + 1) {
                line.prefix = childPrefix + line.prefix;
                line.multilinePrefix = childMultilinePrefix + line.multilinePrefix;
            }
            else if (childIsLast) {
                line.prefix = LinePrefix.LastNestedChild + line.prefix;
                line.multilinePrefix = LinePrefix.LastNestedChild + line.multilinePrefix;
            }
            else {
                line.prefix = LinePrefix.NestedChild + line.prefix;
                line.multilinePrefix = LinePrefix.NestedChild + line.multilinePrefix;
            }
        });
        return childLines;
    });
    return [rootLine, ...nestedLines];
}
function directoryDiagram(node, options) {
    const lines = nodeDiagram(node, [], options);
    const strings = lines.map((line) => prefixBlock(line.label, line.prefix, line.multilinePrefix));
    return strings.join('\n');
}
exports.directoryDiagram = directoryDiagram;
function isMultiline(line) {
    return line.includes('\n');
}
exports.isMultiline = isMultiline;
function prefixBlock(block, prefix, multilinePrefix) {
    if (!isMultiline(block))
        return prefix + block;
    return block
        .split('\n')
        .map((line, index) => (index === 0 ? prefix : multilinePrefix) + line)
        .join('\n');
}
exports.prefixBlock = prefixBlock;
